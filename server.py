import socketimport osimport structimport operatorimport timeimport jsonimport subprocessimport threading# 一次读取内容长度字节buffer = 1024# 建立连接try:    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)    sk.bind(('127.0.0.1', 7777))    sk.listen(10)except socket.error as msg:    print(msg)    sys.exit(1)print('Waiting for connection...')# 服务器端socketdef socket_service():    while True:        conn, addr = sk.accept()        print('Accept new connection from {0}'.format(addr))        conn.send(bytes('Successfully connected to the server!'.encode('utf-8')))        while True:            data = conn.recv(4).decode('utf-8')            if data == 'U':                up(conn, buffer)            elif data == 'D':                down(conn)            elif data == 'CMD':                deal_data(conn, addr)            elif data == 'EXIT':                print('Connection from {0} exit'.format(addr))                break# 上传def up(conn, buffer):    # 4字节的数据长度包    long = conn.recv(4)    # 数据报首部:文件大小    pack_long = struct.unpack('i', long)[0]    # 接收pack_long大小的数据并转为字符串    filejson = conn.recv(pack_long).decode('utf-8')    # 数据解析，转为字典    fileinfo = json.loads(filejson)    filename = fileinfo['filename']    filesize = fileinfo['filesize']    # 将接收到的数据写入文件    with open(filename, 'wb')as f:        while filesize:            if filesize >= buffer:                filedata = conn.recv(buffer)                f.write(filedata)                filesize -= buffer            else:                filedata = conn.recv(filesize)                f.write(filedata)                break        print('File %s upload successful...\n' % filename)        conn.send(bytes('Successful...\n'.encode('utf-8')))# 下载def down(conn):    files = os.listdir()    lis_file = ''    for i in files:        lis_file += i + '\n'    # 文件目录为空    if operator.eq(lis_file, ''):        conn.send(''.encode('utf-8'))    else:        conn.send(lis_file.encode('utf-8'))        while True:            # 接收要下载的文件名            filename = conn.recv(1024).decode('utf-8')            if filename not in files:                conn.send(bytes('No such file!!'.encode('utf-8')))                continue            else:                conn.send(bytes('Start to download!!'.encode('utf-8')))                break        # 文件系统函数返回文件大小        size = os.stat(filename).st_size        info = struct.pack('i', size)        # 文件信息大小打包发送给客户端        conn.send(info)        with open(filename, 'rb')as f:            while True:                file_data = f.read(4096)                if not file_data:                    break                conn.send(file_data)        show = '{0}\nDownload file：{1}:\n{2}byte\nSuccessful...\n\n'.format(            time.strftime('%Y-%m-%d:%H:%M:%S', time.localtime(time.time())), filename, size)        print(show)# 命令行def deal_data(conn, addr):    data = conn.recv(1024).decode()    print('from Client{0} information: {1}'.format(addr, data))    # 产生子进程进程 调用系统命令    res = subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)    # 打印错误信息    err = res.stderr.read()    if err:        msg = err    else:        msg = res.stdout.read()    if len(msg) == 0:        msg = res.stderr.read()    # 制作4位固定表头并发送    conn.send(struct.pack('i', len(msg)))    # 直接循环发送    conn.sendall(msg)if __name__ == '__main__':    socket_service()